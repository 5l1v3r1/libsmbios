#!/usr/bin/python
# vim:expandtab:autoindent:tabstop=4:shiftwidth=4:filetype=python:tw=0

  #############################################################################
  #
  # Copyright (c) 2005 Dell Computer Corporation
  # Dual Licenced under GNU GPL and OSL
  #
  #############################################################################
"""dumpCmos"""

from __future__ import generators

# import arranged alphabetically
import ctypes
import gettext
import locale
import os
import struct
import sys
import time
import traceback

# the following vars are all substituted on install
# this bin isnt byte-compiled, so this is ok
RELEASE_VERSION="uninstalled-version"
pythondir=os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), "..", "python")
clidir=os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), "..", "py-cli")
# end vars

# import all local modules after this.
sys.path.insert(0,pythondir)
sys.path.insert(0,clidir)
__VERSION__=RELEASE_VERSION

import cli
from libsmbios_c import smbios, token, localedir, GETTEXT_PACKAGE
from libsmbios_c.trace_decorator import decorate, traceLog, getLog

# use python-decoratortools if it is installed, otherwise use our own local
# copy. Imported this locally because it doesnt appear to be available on SUSE
# and the fedora RPM doesnt appear to compile cleanly on SUSE
try:
    from peak.util.decorators import decorate_class
except ImportError:
    from libsmbios_c._peak_util_decorators import decorate_class

locale.setlocale(locale.LC_ALL, '')
gettext.install(GETTEXT_PACKAGE, localedir, unicode=1)

class CmdlineError(Exception): pass

RBU_SMBIOS_STRUCT = 0xDE
TOKEN_RBU_CANCEL = 0x005d
TOKEN_RBU_STAGE  = 0x005c

completion_messages = {
    0x0000: _("The update was completed successfully."),
    0x0001: _("The image failed one or more consistency checks."),
    0x0002: _("The BIOS could not access the flash-memory device."),
    0x0003: _("The flash-memory device was not ready when an erase was attempted."),
    0x0004: _("Flash programming is currently disabled on the system, or the voltage is low."),
    0x0005: _("A battery must be installed for the operation to complete."),
    0x0006: _("A fully-charged battery must be present for the operation to complete."),
    0x0007: _("An external power adapter must be connected for the operation to complete."),
    0x0008: _("The 12V required to program the flash-memory could not be set."),
    0x0009: _("The 12V required to program the flash-memory could not be removed."),
    0x000A: _("A flash-memory failure occurred during a block-erase operation."),
    0x000B: _("A general failure occurred during the flash programming."),
    0x000C: _("A data miscompare error occurred during the flash programming."),
    0x000D: _("The image could not be found in memory, i.e. the header could not be located."),
    0xFFFF: _("No update operation has been performed on the system."),
}

failmessage = _("""
Common problems are:

    -- Insufficient permissions to perform operation.
       Try running as a more privileged account.
          Linux  : run as 'root' user
          Windows: run as 'administrator' user

    -- dell_rbu device driver not loaded.
       Try loading the dell_rbu driver
          Linux  : modprobe dell_rbu
          Windows: dell_rbu driver not yet available.
""")

def command_parse():
    parser = cli.OptionParser(usage=__doc__, version=__VERSION__)
    parser.add_option('--hdr', metavar="HDR_FILE", action="store", default=None, help= _("The BIOS update file (.HDR file)"))
    parser.add_option('--hdr-info', metavar="HDR_FILE", action="append", default=[], help= _("Show information about a given BIOS HDR file"))
    parser.add_option('--system-info', action="store_const", const="system_info", dest="action", default=None, help= _("Show system information and RBU completion codes"))
    parser.add_option('--cancel', action="store_const", const="cancel", dest="action", help= _("Cancel pending BIOS update"))
    parser.add_option('--update', action="store_const", const="update", dest="action", help= _("Stage BIOS for update at next reboot"))
    parser.add_option('--test', action="store_const", const="test", dest="action", help= _("Test HDR file to see if it is appropriate for this system"))

    parser.add_option('--auto-detect-mode', action="store_const", const="auto", dest="update_mode", default="auto", help= _("Automatically select the optimal update mode (default, recommended)"))
    parser.add_option('--force-packet-mode', action="store_const", const="packet", dest="update_mode", help= _("Force update to use packet-mode"))
    parser.add_option('--force-mono-mode', action="store_const", const="mono", dest="update_mode", help= _("Force update to use monolithic-mode"))

    parser.add_option('--override-version-check', action="store_false", dest="check_bios_version", default=True, help= _("Allow BIOS downgrades and re-flash"))
    parser.add_option('--override-sysid-check', action="store_false", dest="check_sysid", default=True, help= _("Disable check for system-id (Dangerous)"))
    cli.addStdOptions(parser)
    options, args = parser.parse_args()

    if len(args) == 1 and options.hdr is None:
        options.hdr = args[0]

    return options,args

decorate(traceLog())
def getNum(s, off, len):
    retval = 0
    try:
        t = list(struct.unpack( 'B' * len, s.getData(off, len) ))
        t.reverse()
        for i in t:
            retval = (retval << 8) | i
    except IndexError, e:
        pass
    return retval

decorate(traceLog())
def getCompletion(struct_0xDE=None):
    if struct_0xDE is None:
        struct_0xDE = smbios.SmbiosTable()[RBU_SMBIOS_STRUCT]
    return (getNum(struct_0xDE, 0x06, 2), completion_messages[getNum(struct_0xDE, 0x06, 2)])

decorate(traceLog())
def getRbuLastUpdate(struct_0xDE=None):
    if struct_0xDE is None:
        struct_0xDE = smbios.SmbiosTable()[RBU_SMBIOS_STRUCT]
    return {
        "year": getNum(struct_0xDE, 0x08, 1),
        "month": getNum(struct_0xDE, 0x09, 1),
        "day": getNum(struct_0xDE, 0x0a, 1),
        "hour": getNum(struct_0xDE, 0x0b, 1),
        "minute": getNum(struct_0xDE, 0x0c, 1),
        }

decorate(traceLog())
def getUpdateModes(struct_0xDE=None):
    if struct_0xDE is None:
        struct_0xDE = smbios.SmbiosTable()[RBU_SMBIOS_STRUCT]

    modes = [ "MONOLITHIC" ]
    characteristics = getNum(struct_0xDE, 0x0f, 1)
    if characteristics & 0x01:
        modes.append("PACKET")
    return modes

decorate(traceLog())
def system_info():
    table = smbios.SmbiosTable()
    s = table[RBU_SMBIOS_STRUCT]

    print _("RBU Update information:")
    print _("\tMinimum size: %d") % getNum(s, 0x04, 2)
    print _("\tCompletion Code: %d") %  getCompletion(s)[0]
    print _("\tCompletion Message:\n\t\t%s") %  getCompletion(s)[1]
    print _("\tLast Update Date - Year  : %02x") % getRbuLastUpdate(s)["year"]
    print _("\tLast Update Date - Month : %02x") % getRbuLastUpdate(s)["month"]
    print _("\tLast Update Date - Day   : %02x") % getRbuLastUpdate(s)["day"]
    print _("\tLast Update Date - time  : %02x:%02x") % (getRbuLastUpdate(s)["hour"], getRbuLastUpdate(s)["minute"])
    print _("\tBoot Feature Flags: 0x%08x") % getNum(s, 0x0d, 2)
    print _("\tCharacteristics: 0x%04x") % getNum(s, 0x0f, 1)
    print _("\tUpdate modes supported: %s") % ", ".join(getUpdateModes(s))

decorate(traceLog())
def updateBios(filename, forcetype='auto', check_bios_version=True, check_sysid=True):
    meth = BaseRbu.getRbuMethod(filename, forcetype)
    meth.doUpdate()

decorate(traceLog())
def cancelUpdate():
    print _("Cancelling BIOS update...")
    table = token.TokenTable()
    table[TOKEN_RBU_CANCEL].activate()
    meth = BaseRbu.getRbuMethod(None)
    meth.cancelUpdate()
    print _("BIOS update cancelled.")

decorate(traceLog())
def dumpDataToFile(filename, data, wait=False):
    while wait and not os.path.exists(filename):
        time.sleep(0.1)
    fh = open(filename, "wb")
    fh.write(data)
    fh.close()

decorate(traceLog())
def streamDataToFile(inputStream, outputStream, bufsize=1024):
    while 1:
        buf = inputStream.read(bufsize)
        if buf == "": break
        outputStream.write(buf)

class HdrFile(object):
    decorate(traceLog())
    def __init__(self, filename):
        self.filename = filename
        self.fd = open(filename, "rb")
        self.hdr = HdrFileStructure()
        buf = self.fd.read(ctypes.sizeof(self.hdr))
        self.fd.seek(0,0)
        ctypes.memmove(ctypes.byref(self.hdr), ctypes.byref(ctypes.create_string_buffer(buf)), ctypes.sizeof(self.hdr))

    decorate(traceLog())
    def dumpInfo(self):
        print "test for %s" % self.filename
        print
        print "ID: %s" % self.hdr.headerId
        print "Length: %s" % self.hdr.headerLength
        print "Major: %s" % self.hdr.headerMajorVer
        print "Minor: %s" % self.hdr.headerMinorVer
        print "numSystems: %s" % self.hdr.numSystems
        print "quickCheck: %s" % self.hdr.quickCheck
        print "biosVersion: %s" % self.hdr.biosVersion
        print "miscFlags: %s" % self.hdr.miscFlags
        print "biosInternalOnly: %s" % self.hdr.biosInternalOnly
        for i in self.hdr.reserved:
            print "reserved: 0x%04x" % i
        print "compatFlags: %s" % self.hdr.compatFlags
        for i in range(min(NUM_SYS_ID_IN_HDR, self.hdr.numSystems)):
            print "System ID: 0x%04x" % self.hdr.systemIdList[i]


class BaseRbu(object):
    subclasses = []
    decorate(traceLog())
    def __init__(self, hdrfile):
        self.hdrfile = hdrfile

    decorate(staticmethod)
    decorate(traceLog())
    def getRbuMethod(hdrfile, forcetype="auto"):
        meths = {}
        for i in BaseRbu.subclasses:
            meths[i] = i.validRbuMethod(hdrfile, forcetype)

        retval = (None, 0)
        for cls in meths.keys():
            if meths[cls] > retval[1]:
                retval = (cls, meths[cls])

        if retval[0] is not None:
            return retval[0](hdrfile)
        return None

# use this class decorator on subclasses
def BaseRbuSubclass():
    def decorator(cls):
        BaseRbu.subclasses.append(cls)
        return cls
    decorate_class(decorator)

class MonolithicRbu_v3(BaseRbu):
    BaseRbuSubclass()
    sysbasedir = "/sys/devices/platform/dell_rbu/"
    img_type_file = "/sys/devices/platform/dell_rbu/image_type"
    pkt_size_file = "/sys/devices/platform/dell_rbu/packet_size"
    fw_data_file = "/sys/class/firmware/dell_rbu/data"
    fw_load_file = "/sys/class/firmware/dell_rbu/loading"

    validtypes = ["auto", "mono"]

    decorate(classmethod)
    decorate(traceLog())
    def validRbuMethod(cls, hdrfile=None, forcetype="auto"):
        if not forcetype in cls.validtypes:
            return 0
        if not os.path.exists(cls.img_type_file):
            return 0
        if not cls._checkMode(forcetype):
            return 0
        return 10

    decorate(classmethod)
    decorate(traceLog())
    def _checkMode(cls, forcetype):
        if forcetype != "auto" and forcetype in cls.validtypes:
            return True
        if "MONOLITHIC" not in getUpdateModes():
            return False
        return True

    decorate(traceLog())
    def cancelUpdate(self):
        self.setPacketType('init')
        self.setLoadValue('0')

    decorate(traceLog())
    def doUpdate(self):
        print "Performing MONOLITHIC RBU update..."
        self.setPacketType('init')
        self.setPacketType('mono')
        self.setLoadValue('1')
        outputFd = open(self.fw_data_file, "wb")
        streamDataToFile(self.hdrfile.fd, outputFd)
        outputFd.close()
        self.setLoadValue('0')

    decorate(traceLog())
    def setSize(self, val):
        dumpDataToFile(self.pkt_size_file, str(val), wait=False)

    decorate(traceLog())
    def setLoadValue(self, val):
        dumpDataToFile(self.fw_load_file, val, wait=True)

    decorate(traceLog())
    def setPacketType(self, val):
        dumpDataToFile(self.img_type_file, val, wait=False)

class PacketRbu_v3(MonolithicRbu_v3):
    BaseRbuSubclass()
    validtypes = ["auto", "packet"]
    packetSize = 4096

    decorate(classmethod)
    decorate(traceLog())
    def _checkMode(cls, forcetype):
        if forcetype != "auto" and forcetype in cls.validtypes:
            return True
        if "PACKET" not in getUpdateModes():
            return False

    decorate(traceLog())
    def doUpdate(self):
        print "Performing PACKET RBU update..."
        self.setPacketType('init')
        self.setPacketType('packet')
        self.setSize(0)
        self.setSize(self.packetSize)
        self.setLoadValue('1')
        self.pktUpdateLoop()
        self.setLoadValue('0')

    decorate(traceLog())
    def pktUpdateLoop(self):
        print "pktUpdateLoop()"

        # make header

        while 1:
            buf = self.hdrfile.fd.read(self.packetSize)
            if buf == "":
                break

            # setup pkt header
            #  -- incr pkt# 
            # write pkt

def main():
    exit_code = 0
    (options, args) = command_parse()
    cli.setup_std_options(options)

    if options.hdr_info:
        print _("Getting info for HDR file:")
        for filename in options.hdr_info:
            h = HdrFile(filename)
            h.dumpInfo()
    elif options.action == "system_info":
        try:
            system_info()
        except IndexError, e:
            print _("RBU is not supported on this system.")
        except smbios.TableParseError, e:
            print _("\nERROR: Could not parse system SMBIOS table.")
            print _("\nThe smbios library returned this error:")
            print str(e)
            print
            print failmessage

    elif options.action == "cancel":
        cancelUpdate()
    elif options.action == "update":
        exit_code = updateBios(HdrFile(options.hdr), options.update_mode, options.check_bios_version, options.check_sysid)
    elif options.action == "test":
        exit_code=1
        print _("Test mode not yet implemented... use dellBiosUpdate")

    return exit_code

# current HDR def leaves room for 12 system ids
NUM_SYS_ID_IN_HDR = 12

class HdrFileStructure(ctypes.Structure):
    _pack_ = 1
    _fields_ = [
        #char headerId[4];
        ("headerId", ctypes.c_char * 4),

        #u8  headerLength;
        ("headerLength", ctypes.c_uint8),

        #u8  headerMajorVer;
        ("headerMajorVer", ctypes.c_uint8),

        #u8  headerMinorVer;
        ("headerMinorVer", ctypes.c_uint8),

        #u8  numSystems;
        ("numSystems", ctypes.c_uint8),

        #char quickCheck[40];
        ("quickCheck", ctypes.c_char * 40),

        #char biosVersion[3];
        ("biosVersion", ctypes.c_char * 3),

        #u8  miscFlags;
        ("miscFlags", ctypes.c_uint8),

        #u8  biosInternalUse;
        ("biosInternalOnly", ctypes.c_uint8),

        #u8  reserved[5];
        ("reserved", ctypes.c_uint8 * 5),

        #u16 compatFlags;
        ("compatFlags", ctypes.c_uint16),

        #u16 systemIdList[NUM_SYS_ID_IN_HDR];
        ("systemIdList", ctypes.c_uint16 * NUM_SYS_ID_IN_HDR)

# Contains the list of NumSystems Dell System ID and Hardware Revision
# ID pairs for which the Image Data is valid, in the following format:
#
# Bit Range  Description
# 15:11      Dell System ID, bits 12:8.
#               This range is set to 00000b if the Dell System ID
#               is a 1-byte value.
# 10:8       Hardware Revision ID
# 7:0        Dell System ID, bits 7:0.
        ]

if __name__ == "__main__":
    sys.exit( main() )

